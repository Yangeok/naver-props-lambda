<html>

<head>
  <meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1" />
  <title>지도 위 버튼으로 로드뷰 표시하기</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&family=Noto+Sans+JP&family=Noto+Sans+SC&family=Noto+Sans+TC&display=swap"
    rel="stylesheet">
  <style>
    /* 기본 스타일 */
    body {
      font-family: 'Noto Sans KR', 'Noto Sans JP', 'Noto Sans SC', 'Noto Sans TC', sans-serif;
      margin: 0;
    }

    #container {
      overflow: hidden;
      height: 100%;
      position: relative;
    }

    #mapWrapper {
      width: 100%;
      height: 100%;
      /* 기본적으로 지도가 전체 화면을 차지하도록 설정 */
      z-index: 1;
    }

    #rvWrapper {
      width: 70%;
      height: 100%;
      top: 0;
      right: 0;
      position: absolute;
      z-index: 0;
      display: none;
      /* 기본적으로 로드뷰는 숨겨져 있음 */
    }

    #container.view_roadview #mapWrapper {
      width: 30%;
      /* 로드뷰가 활성화되면 PC에서 맵이 30%로 줄어듬 */
    }

    #container.view_roadview #rvWrapper {
      display: block;
      /* 로드뷰가 활성화되면 로드뷰를 표시 */
    }

    #roadviewControl {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 42px;
      height: 42px;
      z-index: 1;
      cursor: pointer;
      background: url(https://t1.daumcdn.net/localimg/localimages/07/2018/pc/common/img_search.png) 0 -450px no-repeat;
    }

    #roadviewControl.active {
      background-position: 0 -350px;
    }

    #close {
      position: absolute;
      padding: 4px;
      top: 5px;
      left: 5px;
      cursor: pointer;
      background: #fff;
      border-radius: 4px;
      border: 1px solid #c8c8c8;
      box-shadow: 0px 1px #888;
    }

    #close .img {
      display: block;
      background: url(https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/rv_close.png) no-repeat;
      width: 14px;
      height: 14px;
    }

    /* PC 환경 스타일 (화면 너비가 768px 이상일 때) */
    @media screen and (min-width: 768px) {
      #container.view_roadview #mapWrapper {
        width: 30%;
        /* 로드뷰가 활성화되면 맵이 30%로 줄어듬 */
      }

      #rvWrapper {
        width: 70%;
        /* 로드뷰가 활성화되면 로드뷰가 70% 차지 */
        height: 100%;
        position: absolute;
        top: 0;
        right: 0;
      }
    }

    /* 모바일 환경 스타일 (화면 너비가 768px 미만일 때) */
    @media screen and (max-device-width: 1000px),
    screen and (max-width: 767px) {
      #container {
        display: flex;
        flex-direction: column;
      }

      #mapWrapper {
        width: 100%;
        height: 100%;
        /* 로드뷰가 비활성화된 상태에서 지도가 전체를 차지 */
        z-index: 1;
        position: relative;
      }

      #rvWrapper {
        width: 100%;
        height: 50%;
        /* 로드뷰가 활성화되면 로드뷰가 위쪽 50% 차지 */
        position: relative;
        z-index: 0;
        top: 0;
        right: 0;
        display: none;
        /* 기본적으로 로드뷰는 숨겨져 있음 */
      }

      #container.view_roadview #mapWrapper {
        width: 100%;
        height: 50%;
        /* 로드뷰가 활성화되면 맵이 아래쪽 50%로 줄어듬 */
      }

      #container.view_roadview #rvWrapper {
        display: block;
        /* 로드뷰가 활성화되면 로드뷰를 표시 */
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=d4f90e587e6d1842ce8b2bbcc8a3dbff&libraries=services"></script>
</head>

<body>
  <div id="container">
    <div id="rvWrapper">
      <div id="roadview" style="width: 100%; height: 100%;"></div> <!-- 로드뷰를 표시할 div 입니다 -->
      <div id="close" title="로드뷰닫기" onclick="closeRoadview()"><span class="img"></span></div>
    </div>
    <div id="mapWrapper">
      <div id="map" style="width: 100%; height: 100%"></div> <!-- 지도를 표시할 div 입니다 -->
      <div id="roadviewControl" onclick="setRoadviewRoad()"></div>
    </div>
  </div>
  <script>
    let currentInfowindow = null
    let isOpen = false
    const assets = {
      filePath: '/analysis.csv',
      markerRed: '/marker_red.png',
      markerGreen: '/marker_green.png',
      markerBlue: '/marker_blue.png',
      markerBlack: '/marker_black.png',
    }

    let overlayOn = false // 지도 위에 로드뷰 오버레이가 추가된 상태를 가지고 있을 변수
    const container = document.getElementById('container') // 지도와 로드뷰를 감싸고 있는 div 입니다
    const mapWrapper = document.getElementById('mapWrapper') // 지도를 감싸고 있는 div 입니다
    const mapContainer = document.getElementById('map') // 지도를 표시할 div 입니다 
    const rvContainer = document.getElementById('roadview') //로드뷰를 표시할 div 입니다
    const mapCenter = new kakao.maps.LatLng(37.566535, 126.9779692)

    const mapOptions = {
      center: mapCenter,
      level: 8
    }
    const map = new kakao.maps.Map(mapContainer, mapOptions)

    map.setKeyboardShortcuts(true)
    const mapTypeControl = new kakao.maps.MapTypeControl()
    const zoomControl = new kakao.maps.ZoomControl()
    map.addControl(mapTypeControl, kakao.maps.ControlPosition.TOPRIGHT)
    map.addControl(zoomControl, kakao.maps.ControlPosition.RIGHT)

    const rv = new kakao.maps.Roadview(rvContainer);
    const rvClient = new kakao.maps.RoadviewClient();

    const markImage = new kakao.maps.MarkerImage(
      'https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png',
      new kakao.maps.Size(26, 46),
      {
        spriteSize: new kakao.maps.Size(1666, 168),
        spriteOrigin: new kakao.maps.Point(705, 114),
        offset: new kakao.maps.Point(13, 46)
      }
    )

    const marker = new kakao.maps.Marker({
      image: markImage,
      position: mapCenter,
      draggable: true
    })

    kakao.maps.event.addListener(marker, 'click', function () {
      if (container.className.indexOf('view_roadview') === -1) {
        setRoadviewRoad();
      } else {
        closeRoadview();
      }
    });

    kakao.maps.event.addListener(rv, 'position_changed', positionChangeListener)

    kakao.maps.event.addListener(marker, 'dragend', function (mouseEvent) {
      const position = marker.getPosition()

      toggleRoadview(position)
    })

    kakao.maps.event.addListener(map, 'click', function (mouseEvent) {
      if (isOpen && currentInfowindow) {
        currentInfowindow.close();
        isOpen = false;
      }
      if (!overlayOn) {
        return
      }

      const position = mouseEvent.latLng
      marker.setPosition(position)
      toggleRoadview(position)
    })

    function positionChangeListener() {
      const rvPosition = rv.getPosition()
      map.setCenter(rvPosition)
      if (overlayOn) marker.setPosition(rvPosition)
    }

    function makeClickListener(map, marker, infowindow) {
      return () => {
        if (isOpen && currentInfowindow) {
          currentInfowindow.close()
          isOpen = false
        }

        infowindow.open(map, marker)
        currentInfowindow = infowindow
        isOpen = true
      }
    }

    function toggleOverlay(active) {
      if (active) {
        overlayOn = true
        map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW)
        marker.setMap(map)
        marker.setPosition(map.getCenter())
        toggleRoadview(map.getCenter())
      } else {
        overlayOn = false
        map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW)
        marker.setMap(null)
      }
    }

    function setRoadviewRoad() {
      const control = document.getElementById('roadviewControl')
      if (control.className.indexOf('active') === -1) {
        control.className = 'active'
        toggleOverlay(true)
      } else {
        control.className = ''
        toggleOverlay(false)
      }
    }

    function closeRoadview() {
      const position = marker.getPosition()
      toggleMapWrapper(true, position)
    }

    function toggleRoadview(position) {
      rvClient.getNearestPanoId(position, 50, function (panoId) {
        if (panoId === null) {
          toggleMapWrapper(true, position)
        } else {
          toggleMapWrapper(false, position)

          rv.setPanoId(panoId, position)
        }
      })
    }

    function toggleMapWrapper(active, position) {
      if (active) {
        container.className = ''
        map.relayout()
        map.setCenter(position)
      } else {
        if (container.className.indexOf('view_roadview') === -1) {
          container.className = 'view_roadview'
          map.relayout()
          map.setCenter(position)
        }
      }
    }

    function parseDate(str) {
      if (!str) {
        return null
      }
      const [year, month, day] = str.split('.')
      return new Date(`20${year}-${month}-${day}`)
    }

    const DateRange = Object.freeze({
      YESTERDAY: 'YESTERDAY',
      LAST_WEEK: 'LAST_WEEK',
      TWO_WEEKS_AGO: 'TWO_WEEKS_AGO',
      OUT_OF_RANGE: 'OUT_OF_RANGE'
    })

    function checkDateRange(date) {
      if (!date) {
        return DateRange.OUT_OF_RANGE
      }
      const day = 24 * 60 * 60 * 1000
      const today = new Date().setHours(0, 0, 0, 0)
      const tomorrow = new Date(today + day)
      const yesterday = new Date(today - day)
      const oneWeekAgo = new Date(today - (7 * day))
      const twoWeekAgo = new Date(today - (14 * day))

      if (date >= yesterday && date <= tomorrow) {
        return DateRange.YESTERDAY
      } else if (date >= oneWeekAgo && date < yesterday) {
        return DateRange.LAST_WEEK
      } else if (date >= twoWeekAgo && date < oneWeekAgo) {
        return DateRange.TWO_WEEKS_AGO
      } else {
        return DateRange.OUT_OF_RANGE
      }
    }

    const markerRed = new kakao.maps.MarkerImage(
      assets.markerRed,
      new kakao.maps.Size(24, 24),
    )
    const markerBlack = new kakao.maps.MarkerImage(
      assets.markerBlack,
      new kakao.maps.Size(24, 24),
    )
    const markerBlue = new kakao.maps.MarkerImage(
      assets.markerBlue,
      new kakao.maps.Size(24, 24),
    )
    const markerGreen = new kakao.maps.MarkerImage(
      assets.markerGreen,
      new kakao.maps.Size(24, 24),
    )

    function groupBy(array, callback) {
      return array.reduce((acc, item) => {
        const key = callback(item)
        if (!acc[key]) {
          acc[key] = []
        }
        acc[key].push(item)
        return acc
      }, {})
    }

    function filterGroupedItems(groupedItems) {
      return Object.values(groupedItems).filter(group => group.length > 1)
    }

    function filterOutGroupedItems(groupedItems) {
      return Object.values(groupedItems)
        .filter(group => group.length === 1)
        .flat()
    }

    function getLatestDate(dates) {
      return dates.reduce((latest, current) => current > latest ? current : latest)
    }

    fetch(assets.filePath)
      .then(response => response.text())
      .then(text => {
        const csv = Papa.parse(text)

        const data = csv.data.slice(1).map((i, idx) => {
          const dateByDupedItem = i[22] ? JSON.parse(String(i[22]).replace(/'/ig, '"')).sort((a, b) => parseDate(a) - parseDate(b)) : []
          return {
            title: i[3],
            latlng: new kakao.maps.LatLng(i[0], i[1]),
            content: `<div style="width: 400px;">
              <div>${i[3]} ${Number(i[4]) / 10 ** 4}억 (${i[5]}년 승인) 
                <a href="${i[20]}" target="_blank"><img src="https://t1.daumcdn.net/localimg/localimages/07/common/kakaomap_favicon.ico" style="vertical-align: bottom; width: 24px; height: 24px;"/></a> <a href="${i[21]}" target="_blank"><img src="https://www.naver.com/favicon.ico" style="vertical-align: bottom; width: 24px; height: 24px;"/></a>
              </div>
              <div>${i[13]} ${i[10]}m2 ${i[17]} ${i[6]}세대</div>
              <div>${i[15]}/${i[16]}층 방/화장실 ${i[18]}/${i[19]}개</div>
              <div>${i[7]} ${i[8]} ${Number(i[9]).toFixed(0)}m</div>
              <div">${i[11]}</div>
              <div>${i[2]} 등록${i[2] !== dateByDupedItem[0] ? ` (${dateByDupedItem[0]} 최초 등록)` : ''}</div>
            </div>`,
            summary: `<div>${i[3]} ${Number(i[4]) / 10 ** 4}억</div>`,
            date: i[2],
          }
        })

        const groupedData = groupBy(data, i => i.latlng)
        const groupIncludedData = filterGroupedItems(groupedData)
        
        groupIncludedData.forEach(i => {
          const dateRange = checkDateRange(getLatestDate(i.map(j => parseDate(j.date))))
          const marker = new kakao.maps.Marker({
            map,
            position: i[0].latlng,
            title: i[0].title,
            clickable: true,
            image: dateRange === DateRange.YESTERDAY ? markerBlue
              : dateRange === DateRange.LAST_WEEK ? markerGreen
              : dateRange === DateRange.TWO_WEEKS_AGO ? markerRed
              : markerBlack,
          })
          const infowindow = new kakao.maps.InfoWindow({
            content: `${i.map(j => `<div>${j.content}</div>`).join('<hr/>')}`,
            removable: true,
          })

          kakao.maps.event.addListener(marker, 'click', makeClickListener(map, marker, infowindow))
        })

        const groupExcludedData = filterOutGroupedItems(groupedData)
        groupExcludedData.forEach(i => {
          const dateRange = checkDateRange(parseDate(i.date))
          const marker = new kakao.maps.Marker({
            map,
            position: i.latlng,
            title: i.title,
            clickable: true,
            image: dateRange === DateRange.YESTERDAY ? markerBlue
            : dateRange === DateRange.LAST_WEEK ? markerGreen
            : dateRange === DateRange.TWO_WEEKS_AGO ? markerRed
            : markerBlack
          })
          const infowindow = new kakao.maps.InfoWindow({
            content: i.content,
            removable: true,
          })

          kakao.maps.event.addListener(marker, 'click', makeClickListener(map, marker, infowindow))
        })
      })
      .catch(error => console.error('Error loading CSV file:', error))

      document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape') {
          container.className = ''
          map.relayout()

          closeRoadview()
          setRoadviewRoad()
          if (isOpen && currentInfowindow) {
            currentInfowindow.close()
            isOpen = false
          }
        }

        if (event.key === 'R' || event.key === 'r') {
          setRoadviewRoad()
        }
      })
    
      const geocoder = new kakao.maps.services.Geocoder()
      const addressMarker = new kakao.maps.Marker()
      const addressInfowindow = new kakao.maps.InfoWindow({zIndex: 1, removable: true})

      kakao.maps.event.addListener(map, 'click', (mouseEvent) => {
        const latlng = mouseEvent.latLng

        addressMarker.setPosition(latlng)
        addressMarker.setMap(map)

        searchAddrFromCoords(latlng, function(result, status) {
          if (status === kakao.maps.services.Status.OK) {
            const detailAddr = !!result[0].road_address ? result[0].road_address.address_name : result[0].address.address_name
            const content = `
              <div style="padding:10px; width:250px; max-width:250px; white-space: normal; word-break: break-all;">
                ${detailAddr}
              </div>
            `

            addressInfowindow.close()
            addressInfowindow.setContent(content)
            addressInfowindow.open(map, addressMarker)
          }   
        })
      })

      function searchAddrFromCoords(coords, cb) {
        geocoder.coord2Address(coords.getLng(), coords.getLat(), cb)
      }
  </script>
</body>

</html>